Namespace mojo

#Import "<std>"
Using std..


class FontMap
	field _tileMap:short[, , ]
	field _colorMap:short[, , ]
	field _map:short[, ]
	field _pallete:ColorPalette
	field _mapLayer:int = 0

	field _mapWidth:int[] = new int[32]
	field _mapHeight:int[] = new int[32]


	method New( arcadeFont:ArcadeFont, pallete:ColorPalette )
		_arcadeFont = arcadeFont
		_pallete = pallete
	End

	method New( font1:ArcadeFont, font2:ArcadeFont, pallete:ColorPalette )
		_font1 = font1
		_font2 = font2
		_arcadeFont = font1
		_pallete = pallete
	End
	
	Property Palette:ColorPalette()
		Return _pallete
	Setter( palette:ColorPalette )
		_pallete = palette
	End

	Property Font:ArcadeFont()
		Return _arcadeFont
	Setter( font:ArcadeFont )
		_arcadeFont = font
	End
	
	Property Count:int()
		Return _layerCount
	End
	
	Property CollideTL:bool()
		Return _collideTL
	End
	Property CollideTR:bool()
		Return _collideTR
	End
	Property CollideBL:bool()
		Return _collideBL
	End
	Property CollideBR:bool()
		Return _collideBR
	End

	Property DivX:float()
		Return _divx
	End
	Property DivY:float()
		Return _divy
	End


	
	method UseFont( fnt:int )
		Select Clamp( fnt,  1, 2 )
			Case 1
				if _font1 then _arcadeFont = _font1
			Case 2
				if _font2 then _arcadeFont = _font2
		End Select
	End method
	

	method CopyMap( fromMap:FontMap )
		local m:int
		Local x:int
		Local y:int

		_layerCount = fromMap.Count
		_tileMap = New short[_layerCount+1, 128, 128]
		_colorMap = New short[_layerCount+1, 128, 128]

		For m = 0 to fromMap.Count
			For x = 0 To 127'_mapWidth[ toMap ]
				For y = 0 To 127'_mapHeight[ toMap ]
					_tileMap[ m, x, y ] = fromMap._tileMap[ m, x, y ]
					_colorMap[ m, x, y ] = fromMap._colorMap[ m, x, y ]
				Next
			Next
		Next
	End method
	
	
	method Copy( fromMap:int, toMap:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127'_mapWidth[ toMap ]
			For y = 0 To 127'_mapHeight[ toMap ]
				_tileMap[ toMap, x, y ] = _tileMap[ fromMap, x, y ]
				_colorMap[ toMap, x, y ] = _colorMap[ fromMap, x, y ]
			Next
		Next
	End method


	method CopyIgnoreColor( fromMap:int, toMap:int, col:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127
			For y = 0 To 127
				If _colorMap[ fromMap, x, y ] = col Then
					_tileMap[ toMap, x, y ] = 0
					_colorMap[ toMap, x, y ] = 0
				Else
					_tileMap[ toMap, x, y ] = _tileMap[ fromMap, x, y ]
					_colorMap[ toMap, x, y ] = _colorMap[ fromMap, x, y ]
				End If
			Next
		next
	End method


	method DjikstraCol( layer:int, xstart:int, ystart:int, ignoreTileAbove:int, count:int = 255 )
		Local x:int
		Local y:int
		
		Local width:int = _mapWidth[layer]
		Local height:int = _mapHeight[layer]
		If xstart < 0 Or xstart > width Then Return
		If ystart < 0 Or ystart > height Then Return
'		Print "layer: "+layer+"  w/h: "+width+" "+height+"  start: "+xstart+" "+ystart
		
		For x = 0 Until width
			For y = 0 Until height
				_colorMap[ layer, x, y ] = 999
			Next
		Next
		
		_colorMap[ layer, xstart, ystart ] = 0

		local k:int
		local last:int = 0
		For k = 1 To count
			For x = 1 To width -2
				For y = 1 To height -2
					If _tileMap[ layer, x, y ] < ignoreTileAbove Then
						if _colorMap[ layer, x-1, y ] = last or _colorMap[ layer, x+1, y ] = last or
							 	_colorMap[ layer, x, y-1 ] = last or _colorMap[ layer, x, y+1 ] = last Then
							 	
							If _colorMap[ layer, x, y ] > last Then
								_colorMap[ layer, x, y ] = k
							End if
							
'							Print "dj:"+x+" "+y+"  "+k
						End If
					End If
				Next
			Next
			last += 1
		Next

		For x = 0 Until width
			For y = 0 Until height
				Clamp( _colorMap[ layer, x, y ], 0, 255 )
			Next
		Next
	End method
	
	
	method Reset()
		_mapLayer = 0
		_layerCount = -1
	End method
	
	
	method Transfer( map:FontMap, fromMap:int, toMap:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127
			For y = 0 To 127
				_tileMap[ toMap, x, y ] = map._tileMap[ fromMap, x, y ]
				_colorMap[ toMap, x, y ] = map._colorMap[ fromMap, x, y ]
			Next
		next
	End method


	method Clear( fromMap:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127
			For y = 0 To 127
				_tileMap[ fromMap, x, y ] = 0
				_colorMap[ fromMap, x, y ] = 0
			Next
		next
	End method

	method ClearColor( fromMap:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127
			For y = 0 To 127
				_colorMap[ fromMap, x, y ] = 0
			Next
		next
	End method

	method ClearTile( fromMap:int, tile:int )
		Local x:int
		Local y:int
		
		For x = 0 To 127
			For y = 0 To 127
				If _tileMap[ fromMap, x, y ] = tile Then
					_tileMap[ fromMap, x, y ] = 0
					_colorMap[ fromMap, x, y ] = 0
				End if
			Next
		next
	End method

	method SwapRndTile( fromMap:int, tile:int, toThing:int )
		Local x:int
		Local y:int
		local changed:bool = False
		
'		repeat
			For x = 0 To 127
				For y = 0 To 127
					If not changed and _tileMap[ fromMap, x, y ] = tile Then
'						Print "found:"+x
						If Rnd(100) < 20 Then
							_tileMap[ fromMap, x, y ] = toThing
							_colorMap[ fromMap, x, y ] = 0
							changed = True
						End If
					End If
				Next
			Next
'		Until changed
	End method

	method Reverse( fromMap:int )
		Local x:int
		Local y:int
		
'		Print _loadX
		
		For y = 0 To 127
			For x = 0 To _loadX
				_tileMap[ fromMap, 127-x, y ] = _tileMap[ fromMap, x, y ]
				_colorMap[ fromMap, 127-x, y ] = _colorMap[ fromMap, x, y ]
			Next
			For x = 0 To _loadX
				_tileMap[ fromMap, x, y ] = _tileMap[ fromMap, 127-_loadX+x, y ]
				_colorMap[ fromMap, x, y ] = _colorMap[ fromMap, 127-_loadX+x, y ]
			Next
		next
	End method

	method Load:bool( filePath:string )
		Print "loading..."
		If Not filePath Return False
		if ExtractExt( filePath ).ToLower() <> ".mx2map" Then Return false

		Local fStream:Stream = Stream.Open( filePath, "r" )
		If not fStream Then
			Print "XX "+filePath + " not opened"
			Return false
		End If
		
		local id:int = fStream.ReadInt()
		If id <> -9999 Then
			Print filePath + " ID error"
			fStream.Close()
			Return false
		End If

		local layers:int = fStream.ReadInt()
		Print "layers to load "+layers
		_layerCount = layers-1

		_tileMap = New short[layers, 128, 128]
		_colorMap = New short[layers, 128, 128]
		_map = New short[128, 128]
		
		
		Local k:int
		For k = _mapLayer To _mapLayer+layers-1
			If k < 32 Then
				LoadLayer( fStream, k )
			End If
		Next
				
		fStream.Close()
		
		_mapLayer = layers-1
		Return true
	End method


	method SetRenderRes( width:int,  height:int, xoffset:int = 0 )
		_divx = int(float(width) / _mapWidth[ 0 ])
		_divy = int(float(height) / _mapHeight[ 0 ])
		_divx2 = _divx+xoffset
		_renderWidth = width
		_renderHeight = height
	End method

	method SetRenderResFromLayer( layer:int, width:int,  height:int )
		_divx = int(float(width) / _mapWidth[ layer ])
		_divy = int(float(height) / _mapHeight[ layer ])
	End method

	method SetDivRes( divX:float, divY:float,  width:int, height:int )
		_renderWidth = width
		_renderHeight = height
		_divx = divX
		_divy = divY
	End method

	
	method SetDiv( divX:float, divY:float )
		_divx = divX
		_divy = divY
	End method

	method IntDiv()
		_divx = int(_divx)
		_divy = int(_divy)
	End method

	Function Chr:String(character:Int)
    	Return String.FromChar(character)
	End
	
	
	method GetBoolFrom:bool( layer:int,  x:int, y:int,  check:string )
		If check = "" or check.Length > 1 Then Return False

		Return check = Chr( _tileMap[ layer, x, y ] )
	End method


	method GetIntFrom:int( layer:int,  x:int, y:int,  count:int = 1 )
		If count < 1 or count > 6 Then Return 0
		count -= 1
		
		x += count
		
		Local k:int
		Local num:int = 0
		Local times:int = 1
		Local input:int
		
		For k = 0 To count
			input = Clamp( _tileMap[ layer, x-k, y ] - 48,  0, 9 )
			
			num += input * times
			times *= 10
		Next
		
		Return num
	End method
	
	
	method Render( canvas:Canvas, layer:int, xs:float, ys:float,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			
			If yp > _renderHeight Then return
		next
	End method


	method RenderIgnore( canvas:Canvas, layer:int, xs:float, ys:float,  ignore:int = 256 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 and _colorMap[layer, x, y] < ignore Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderReplace( canvas:Canvas, layer:int, xs:float, ys:float,  replace:int, with1:int, with2:int = -1 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 and _tileMap[layer, x, y] = replace Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						_arcadeFont.DrawCharSizeWH( canvas, with1, xp, yp, _divx, _divy )
						canvas.Color = Color.White
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method

	method RenderReplace2( canvas:Canvas, layer:int, xs:float, ys:float,  replace:int, with1:int, with2:int )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 and _tileMap[layer, x, y] = replace Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						_arcadeFont.DrawCharSizeWH( canvas, with1, xp, yp, _divx, _divy )
						canvas.Color = Color.White
						_arcadeFont.DrawCharSizeWH( canvas, with2, xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method

	method RenderPercent( canvas:Canvas, layer:int, xs:float, ys:float,  percent:float )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0
		
		Local per:float = 1.0 / (_mapHeight[ layer ] * _mapWidth[ layer ])
		Local count:float = 0
		
		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If percent > count Then
					If x < 128 And y < 128 Then
						If _colorMap[layer, x, y] > 0 Then
							canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
							_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
						End If
					End If
				End If
				count += per
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderPureAnim( canvas:Canvas, layer:int, xs:float, ys:float,  animFrom:int,  animTo:int,  time:int )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0
		Local md:int = (animTo - animFrom)+1
		
		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						If _tileMap[layer, x, y] >= animFrom And _tileMap[layer, x, y] <= animTo Then
							_arcadeFont.DrawCharPureSizeWH( canvas, animFrom + ((_tileMap[layer, x, y]-animFrom+time) Mod md), xp, yp, _divx, _divy )
						Else
							_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
						End if
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderPure( canvas:Canvas, layer:int, xs:float, ys:float,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderPure( canvas:Canvas, layer:int, xs:float, ys:float, palette:ColorPalette,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = palette.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method CheckCollide:bool( layer:int, xs:float, ys:float,  color:int,  colx:float, coly:float, wd:int, ht:int )
		Local x:int
		Local y:int
		local yst:int = 0
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
			yst += 1
		Wend
		
		local colx1:float = colx + wd
		local coly1:float = coly + ht
		
		_collideTL = False
		_collideTR = False
		_collideBL = False
		_collideBR = False
		
		For y = yst until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] = color Then
						If colx > xp And colx < xp+_divx Then
							_collideTL = coly > yp And coly < yp+_divy
							_collideBL = coly1 > yp And coly1 < yp+_divy
						End If
						If colx1 > xp And colx1 < xp+_divx Then
							_collideTR = coly > yp And coly < yp+_divy
							_collideBR = coly1 > yp And coly1 < yp+_divy
						End If
						If _collideTL or _collideTR or _collideBL or _collideBR Then Return true
'						If (colx > xp And colx < xp+_divx) or (colx1 > xp And colx1 < xp+_divx) Then
'							If (coly > yp And coly < yp+_divy) or (coly1 > yp And coly1 < yp+_divy) Then
'								Return true
'							End If
'						End If
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then Return false
		Next
		Return false
	End method
	
	
	method CheckCollide2:bool( layer:int, xs:float, ys:float,  color:int,  colx:float, coly:float, wd:int, ht:int )
		Local x:int
		Local y:int
		local yst:int = 0
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
			yst += 1
		Wend
		
		local colx1:float = colx + wd
		local coly1:float = coly + ht
		
		_collideTL = False
		_collideTR = False
		_collideBL = False
		_collideBR = False
		
		For y = yst until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > color Then
'						Print _colorMap[layer, x, y] +" "+ color
						If colx > xp And colx < xp+_divx Then
							_collideTL = coly > yp And coly < yp+_divy
							_collideBL = coly1 > yp And coly1 < yp+_divy
						End If
						If colx1 > xp And colx1 < xp+_divx Then
							_collideTR = coly > yp And coly < yp+_divy
							_collideBR = coly1 > yp And coly1 < yp+_divy
						End If
						If _collideTL or _collideTR or _collideBL or _collideBR Then Return true
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then Return false
		Next
		Return false
	End method
	
	
	method RenderPureColor( canvas:Canvas, layer:int, xs:float, ys:float,  color:int )
		Local x:int
		Local y:int
		local yst:int = 0
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
			yst += 1
		Wend
		
		For y = yst until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] = color Then
'						canvas.Color = palette.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		Next
	End method


	method RenderPure2( canvas:Canvas, layer:int, xs:float, ys:float,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return
		next
	End method

	method RenderPure2( canvas:Canvas, font:ArcadeFont, layer:int, xs:float, ys:float,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						font.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return
		next
	End method


	method RenderPureY( canvas:Canvas, layer:int, xs:float, ys:float,  yps:int,  palette:ColorPalette,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = yps until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = palette.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderVSlicePureY( canvas:Canvas, layer:int, slice:int, xs:float, ys:float,  yps:int,  width:int, height:int, palette:ColorPalette,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = yps until _mapHeight[ layer ]
			xp = xs
'			For x = 0 Until _mapWidth[ layer ]
'				If x < 128 And y < 128 Then
					If _colorMap[layer, slice, y] > 0 Then
						canvas.Color = palette.GetRGBA( _colorMap[layer, slice, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, slice, y], xp, yp, width, height )
					End If
'				End If
'				xp += _divx
'			Next
			yp += height
			If yp > _renderHeight Then return

		next
	End method


	method RenderColPure( canvas:Canvas, layer:int, xs:float, ys:float )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method Render( canvas:Canvas, layer:int, xs:float, ys:float, palette:ColorPalette,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = palette.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderPalette( canvas:Canvas, layer:int, xs:float, ys:float,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						canvas.DrawRect( xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy

			If yp > _renderHeight Then return

		next
	End method


	method RenderPalette( canvas:Canvas, layer:int, xs:float, ys:float, w:float, h:float )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = ys
		Local xx:int
		Local yy:int = 0
		
		Local divx:float = w / _mapWidth[ layer ]
		Local divy:float = h / _mapHeight[ layer ]

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						canvas.DrawRect( xp, yp, divx, divy )
					End If
				End If
				xp += divx
			Next
			yp += divy

'			If yp > _renderHeight Then return
		next
	End method


	method RenderAtXY( canvas:Canvas, layer:int, xn:int, yn:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn * _divy
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = 0 until _mapHeight[ layer ]
			xp = xn * _divx
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderAtXYCol( canvas:Canvas, layer:int, xn:int, yn:int,  col:Color )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn * _divy
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend

		canvas.Color = col
		
		For y = 0 until _mapHeight[ layer ]
			xp = xn * _divx
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
'						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderOffsetAtXY( canvas:Canvas, layer:int, xn:int, yn:int,  offset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn * _divy
		Local xx:int
		Local yy:int = 0

		While yp + _divy < 0
			yp += _divy
		Wend
		
		local char:int
		
		For y = 0 until _mapHeight[ layer ]
			xp = xn * _divx
			For x = 0 Until _mapWidth[ layer ]
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						char = _tileMap[layer, x, y]+offset
						If char > -1 And char < 256 Then
							canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
							_arcadeFont.DrawCharSizeWH( canvas, char, xp, yp, _divx, _divy )
						End if
					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return
		next
	End method


	method RenderBlockXYWH( canvas:Canvas, layer:int, xs:int, ys:int, w:float, h:float, charStart:int = 0, charEnd:int = 255 )
		Local x:int
		Local y:int

		Local xp:float
		Local yp:float = ys
		
		local divx:float = w / _mapWidth[ layer ]
		local divy:float = h / _mapHeight[ layer ]

		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]

				If _colorMap[layer, x, y] > 0 and _tileMap[layer, x, y] >= charStart And _tileMap[layer, x, y] <= charEnd Then
					canvas.DrawRect( xp, yp, divx, divy )
'					_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, divx, divy )
				End If

				xp += divx
			Next
			yp += divy
			If yp > _renderHeight Then Return
		Next
	End method


	method RenderXYWH( canvas:Canvas, layer:int, xs:int, ys:int, w:float, h:float, charStart:int = 0, charEnd:int = 255 )
		Local x:int
		Local y:int

		Local xp:float
		Local yp:float = ys
		
		local divx:float = w / _mapWidth[ layer ]
		local divy:float = h / _mapHeight[ layer ]

		For y = 0 until _mapHeight[ layer ]
			xp = xs
			For x = 0 Until _mapWidth[ layer ]

				If _colorMap[layer, x, y] > 0 and _tileMap[layer, x, y] >= charStart And _tileMap[layer, x, y] <= charEnd then
					_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, divx, divy )
				End If

				xp += divx
			Next
			yp += divy
			If yp > _renderHeight Then Return
		Next
	End method


	method RenderAtXYWHCol( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int, count:int = -1 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		
		local cnt:int = 0
		width = xs+width
		height = ys+height
		
		For y = ys until height
			xp = xn
			For x = xs Until width
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
						If count > 0 Then
							cnt += 1
							If cnt >= count Then Return
						End If
					End If
				End If
				xp += _divx2
			Next
			yp += _divy
			If yp > _renderHeight Then return
		Next
	End method

	method RenderBoldAtXYWHCol( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int, count:int = -1 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		
		local cnt:int = 0
		width = xs+width
		height = ys+height
		
		For y = ys until height
			xp = xn
			For x = xs Until width
				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp-1, yp, _divx, _divy )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp+1, yp, _divx, _divy )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp-1, _divx, _divy )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp+1, _divx, _divy )
						If count > 0 Then
							cnt += 1
							If cnt >= count Then Return
						End If
					End If
				End If
				xp += _divx2
			Next
			yp += _divy
			If yp > _renderHeight Then Return
		next
	End method

	method RenderAtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

		While yp + _divy < 0
			yp += _divy
		Wend
		
		width = xs+width
		height = ys+height
		For y = ys until height
			xp = xn
			For x = xs Until width
				If x < 128 And y < 128 Then
'					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
'					End If
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method

	method RenderAtXYWH( canvas:Canvas, layer:int, xn:float, yn:float,  xs:int, ys:int, width:int, height:int,  scalex:float, scaley:float )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

		While yp + scaley < 0
			yp += scaley
		Wend
		
		width = xs+width
		height = ys+height
		For y = ys until height
			xp = xn
			For x = xs Until width
				If x < 128 And y < 128 Then
'					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y] )
						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, scalex, scaley )
'					End If
				End If
				xp += scalex
			Next
			yp += scaley
			If yp > _renderHeight Then return

		next
	End method

	method RenderPureAtXYWH( canvas:Canvas, font:ArcadeFont, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
		local col:int
		
		width = xs+width
		height = ys+height

		While yp + _divy < 0
			yp += _divy
			ys += 1
		Wend
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
					col =  _colorMap[layer, x, y]+colOffset
					If col > 0 Then
						canvas.Color = _pallete.GetRGBA( col )
						font.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End if
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return
		next
	End method
	

	method RenderPureAtXYWH( canvas:Canvas, font:ArcadeFont, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  col:Color )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
'		local col:int
		
		width = xs+width
		height = ys+height

		While yp + _divy < 0
			yp += _divy
			ys += 1
		Wend
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
					If _colorMap[layer, x, y] > 0 Then
						canvas.Color = col'_pallete.GetRGBA( col )
						font.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End if
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return
		next
	End method
	

	method RenderPureAtXYWH( canvas:Canvas, font:ArcadeFont, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  divx:float, divy:float )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
		local col:int
		
		width = xs+width
		height = ys+height

		While yp + divy < 0
			yp += divy
			ys += 1
		Wend
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
					col =  _colorMap[layer, x, y]
					If col > 0 Then
						canvas.Color = _pallete.GetRGBA( col )
						font.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, divx, divy )
					End if
				End If
				xp += divx
			Next
			yp += divy
			If yp > _renderHeight Then return
		next
	End method
	
		
	method RenderPureAtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
		local col:int
		
		width = xs+width
		height = ys+height

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
					col =  _colorMap[layer, x, y]+colOffset
'					If col > 0 Then
						canvas.Color = _pallete.GetRGBA( col )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
'					End if
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method
	
	method RenderBlankPureAtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
		
		width = xs+width
		height = ys+height

		While yp + _divy < 0
			yp += _divy
		Wend
		
		local col:int
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
					col =  _colorMap[layer, x, y]+colOffset
					If col > 0 Then
						canvas.Color = Color.Black
						canvas.DrawRect( xp, yp, _divx, _divy )
						canvas.Color = _pallete.GetRGBA( col )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End if
				End If
				xp += _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderRBlankPureAtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

		local xx:float = width * _divx
		
		height = ys+height

		While yp + _divy < 0
			yp += _divy
		Wend
		
		local col:int
		
'		canvas.Color = Color.Gold
'		canvas.DrawFrame( xn, yn, width * 8, height * 8 )
		
		For y = ys until height
			xp = xn+(width*_divx)-_divx
			For x = xs to xs+width-1

				If x < 128 And y < 128 Then
					col =  _colorMap[layer, x, y]+colOffset
					If col > 0 Then
						canvas.Color = Color.Black
						canvas.DrawRect( xp, yp, _divx, _divy )
						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharRPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
					End if
				End If
				xp -= _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method


	method RenderRPureAtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int,  colOffset:int = 0 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn

		local xx:int = width * _divx
		
'		width = xs+width
		height = ys+height

		While yp + _divy < 0
			yp += _divy
		Wend
		
		For y = ys until height
			xp = xn+(width*_divx)-_divx
			For x = xs to xs+width-1
'		For y = ys until height
'			xp = xn+width+xx-_divx
'			For x = xs Until width

				If x < 128 And y < 128 Then
					canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
					_arcadeFont.DrawCharRPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
				End If
				xp -= _divx
			Next
			yp += _divy
			If yp > _renderHeight Then return

		next
	End method

	method RenderPure2AtXYWH( canvas:Canvas, layer:int, xn:int, yn:int,  xs:int, ys:int, width:int, height:int, size:int = -1 )
		Local x:int
		Local y:int
		Local xp:float
		Local yp:float = yn
		
		width = xs+width
		height = ys+height

'		While yp + _divy < 0
'			yp += _divy
'		Wend
		Local divx:float = _divx
		Local divy:float = _divy
		If size > -1 Then
			divx = size
			divy = size
		End If
		
		For y = ys until height
			xp = xn
			For x = xs Until width

				If x < 128 And y < 128 Then
'					If _colorMap[layer, x, y] > 0 Then
'						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
						_arcadeFont.DrawCharPureSizeWH( canvas, _tileMap[layer, x, y], xp, yp, divx, divy )
'					End If

'						canvas.Color = _pallete.GetRGBA( _colorMap[layer, x, y]+colOffset )
'						_arcadeFont.DrawCharSizeWH( canvas, _tileMap[layer, x, y], xp, yp, _divx, _divy )
				End If
				xp += divx
			Next
			yp += divy
			If yp > _renderHeight Then return

		next
	End method
	
	field _divx:float
	field _divy:float
	field _divx2:float

protected

	method LoadLayer( Stream:Stream, layer:int )
		_loadX = Stream.ReadInt()
		_loadY = Stream.ReadInt()
		
		Print "layer "+layer+" size is "+(_loadX+1)+" "+(_loadY+1)

		Local rt:short
		Local cl:short
		
		Local x:int
		Local y:int
		For x = 0 To _loadX
			For y = 0 To _loadY
				cl = Stream.ReadShort()
				rt = Stream.ReadShort()
				If x < 128 And y < 128 Then
					_tileMap[ layer, x, y] = Clamp(int(cl), 0, 255)
					_colorMap[ layer, x, y] = Clamp(int(rt), 0, 255)
				End if
			Next
		Next
		
		_mapWidth[ layer ] = _loadX + 1
		_mapHeight[ layer ] = _loadY + 1
	End method

private	
	field _arcadeFont:ArcadeFont
	field _font1:ArcadeFont
	field _font2:ArcadeFont
	
	field _renderWidth:int
	field _renderHeight:int

	field _loadX:int
	field _loadY:int
	
	field _collideTL:Bool
	field _collideTR:Bool
	field _collideBL:Bool
	field _collideBR:Bool
	
	field _layerCount:int = -1
End